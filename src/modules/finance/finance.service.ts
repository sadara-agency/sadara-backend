import { Op, QueryTypes } from 'sequelize';
import { randomUUID } from 'crypto';
import { sequelize } from '../../config/database';
import { Invoice, Payment, LedgerEntry, Valuation, type PaymentStatus } from './finance.model';
import { Player } from '../players/player.model';
import { Club } from '../clubs/club.model';
import { User } from '../Users/user.model';
import { AppError } from '../../middleware/errorHandler';
import { parsePagination, buildMeta } from '../../shared/utils/pagination';

const PLAYER_ATTRS = ['id', 'firstName', 'lastName', 'firstNameAr', 'lastNameAr', 'photoUrl'] as const;
const CLUB_ATTRS = ['id', 'name', 'nameAr', 'logoUrl'] as const;

// ══════════════════════════════════════════
// INVOICES
// ══════════════════════════════════════════

export async function listInvoices(queryParams: any) {
  const { limit, offset, page, sort, order, search } = parsePagination(queryParams, 'createdAt');
  const where: any = {};
  if (queryParams.status) where.status = queryParams.status;
  if (queryParams.playerId) where.playerId = queryParams.playerId;
  if (queryParams.clubId) where.clubId = queryParams.clubId;
  if (search) {
    where[Op.or] = [
      { invoiceNumber: { [Op.iLike]: `%${search}%` } },
      { description: { [Op.iLike]: `%${search}%` } },
      { '$player.first_name$': { [Op.iLike]: `%${search}%` } },
      { '$player.last_name$': { [Op.iLike]: `%${search}%` } },
      { '$club.name$': { [Op.iLike]: `%${search}%` } },
    ];
  }
  const { count, rows } = await Invoice.findAndCountAll({
    where, limit, offset, order: [[sort, order]], subQuery: false,
    include: [
      { model: Player, as: 'player', attributes: [...PLAYER_ATTRS] },
      { model: Club, as: 'club', attributes: [...CLUB_ATTRS] },
    ],
  });
  return { data: rows, meta: buildMeta(count, page, limit) };
}

export async function getInvoiceById(id: string) {
  const inv = await Invoice.findByPk(id, {
    include: [
      { model: Player, as: 'player', attributes: [...PLAYER_ATTRS] },
      { model: Club, as: 'club', attributes: [...CLUB_ATTRS] },
      { model: User, as: 'creator', attributes: ['id', 'fullName'] },
    ],
  });
  if (!inv) throw new AppError('Invoice not found', 404);
  return inv;
}

export async function createInvoice(input: any, userId: string) {
  // invoice_number auto-generated by DB trigger
  return await Invoice.create({ ...input, invoiceNumber: '', createdBy: userId });
}

export async function updateInvoice(id: string, input: any) {
  const inv = await Invoice.findByPk(id);
  if (!inv) throw new AppError('Invoice not found', 404);
  if (inv.status === 'Paid') throw new AppError('Cannot modify a paid invoice', 400);
  return await inv.update(input);
}

export async function updateInvoiceStatus(id: string, input: any) {
  const inv = await Invoice.findByPk(id);
  if (!inv) throw new AppError('Invoice not found', 404);
  const data: any = { status: input.status };
  if (input.status === 'Paid') data.paidDate = input.paidDate || new Date().toISOString().split('T')[0];
  return await inv.update(data);
}

export async function deleteInvoice(id: string) {
  const inv = await Invoice.findByPk(id);
  if (!inv) throw new AppError('Invoice not found', 404);
  if (inv.status === 'Paid') throw new AppError('Cannot delete a paid invoice', 400);
  await inv.destroy();
  return { id };
}

// ══════════════════════════════════════════
// PAYMENTS
// ══════════════════════════════════════════

export async function listPayments(queryParams: any) {
  const { limit, offset, page, sort, order } = parsePagination(queryParams, 'dueDate');
  const where: any = {};
  if (queryParams.status) where.status = queryParams.status;
  if (queryParams.paymentType) where.paymentType = queryParams.paymentType;
  if (queryParams.playerId) where.playerId = queryParams.playerId;
  const { count, rows } = await Payment.findAndCountAll({
    where, limit, offset, order: [[sort, order]],
    include: [{ model: Player, as: 'player', attributes: [...PLAYER_ATTRS] }],
  });
  return { data: rows, meta: buildMeta(count, page, limit) };
}

export async function createPayment(input: any) {
  return await Payment.create(input);
}

export async function updatePaymentStatus(id: string, input: any) {
  const pay = await Payment.findByPk(id);
  if (!pay) throw new AppError('Payment not found', 404);
  const data: any = { status: input.status };
  if (input.status === 'Paid') data.paidDate = input.paidDate || new Date().toISOString().split('T')[0];
  if (input.reference) data.reference = input.reference;
  return await pay.update(data);
}

// ══════════════════════════════════════════
// LEDGER
// ══════════════════════════════════════════

export async function listLedger(queryParams: any) {
  const { limit, offset, page, sort, order, search } = parsePagination(queryParams, 'postedAt');
  const where: any = {};
  if (queryParams.side) where.side = queryParams.side;
  if (queryParams.account) where.account = { [Op.iLike]: `%${queryParams.account}%` };
  if (queryParams.playerId) where.playerId = queryParams.playerId;
  if (search) {
    where[Op.or] = [
      { description: { [Op.iLike]: `%${search}%` } },
      { account: { [Op.iLike]: `%${search}%` } },
    ];
  }
  const { count, rows } = await LedgerEntry.findAndCountAll({
    where, limit, offset, order: [[sort, order]],
    include: [{ model: Player, as: 'player', attributes: [...PLAYER_ATTRS] }],
  });
  return { data: rows, meta: buildMeta(count, page, limit) };
}

export async function createLedgerEntry(input: any, userId: string) {
  return await LedgerEntry.create({ ...input, createdBy: userId });
}

// ── Create a balanced double-entry pair ──
export async function createLedgerPair(debitAccount: string, creditAccount: string, amount: number, description: string, refType: string, refId: string, playerId: string | null, userId: string) {
  const txId = randomUUID();
  const base = { transactionId: txId, amount, currency: 'SAR', description, referenceType: refType, referenceId: refId, playerId, createdBy: userId };
  await LedgerEntry.bulkCreate([
    { ...base, side: 'Debit' as const, account: debitAccount },
    { ...base, side: 'Credit' as const, account: creditAccount },
  ]);
  return txId;
}

// ══════════════════════════════════════════
// VALUATIONS
// ══════════════════════════════════════════

export async function listValuations(queryParams: any) {
  const { limit, offset, page, sort, order } = parsePagination(queryParams, 'valuedAt');
  const where: any = {};
  if (queryParams.playerId) where.playerId = queryParams.playerId;
  const { count, rows } = await Valuation.findAndCountAll({
    where, limit, offset, order: [[sort, order]],
    include: [{ model: Player, as: 'player', attributes: [...PLAYER_ATTRS] }],
  });
  return { data: rows, meta: buildMeta(count, page, limit) };
}

export async function createValuation(input: any) {
  const player = await Player.findByPk(input.playerId);
  if (!player) throw new AppError('Player not found', 404);

  // Auto-compute trend from previous valuation
  const prev = await Valuation.findOne({ where: { playerId: input.playerId }, order: [['valued_at', 'DESC']] });
  if (prev && !input.trend) {
    const prevVal = Number(prev.value);
    if (input.value > prevVal) { input.trend = 'up'; input.changePct = ((input.value - prevVal) / prevVal * 100).toFixed(2); }
    else if (input.value < prevVal) { input.trend = 'down'; input.changePct = ((input.value - prevVal) / prevVal * 100).toFixed(2); }
    else { input.trend = 'stable'; input.changePct = 0; }
  }

  return await Valuation.create(input);
}

// ══════════════════════════════════════════
// FINANCE SUMMARY (for KPIs + overview)
// ══════════════════════════════════════════

export async function getFinanceSummary(months = 12) {
  const [invoiceStats] = await sequelize.query(`
    SELECT
      SUM(CASE WHEN status = 'Paid' THEN total_amount ELSE 0 END)::NUMERIC AS total_paid,
      SUM(CASE WHEN status = 'Expected' THEN total_amount ELSE 0 END)::NUMERIC AS total_pending,
      SUM(CASE WHEN status = 'Overdue' THEN total_amount ELSE 0 END)::NUMERIC AS total_overdue,
      COUNT(*) FILTER (WHERE status = 'Overdue')::INT AS overdue_count,
      COUNT(*)::INT AS total_invoices
    FROM invoices
  `, { type: QueryTypes.SELECT }) as any[];

  const upcomingPayments = await Payment.count({ where: { status: 'Expected' } });

  const revenueByMonth = await sequelize.query(`
    SELECT TO_CHAR(DATE_TRUNC('month', paid_date), 'YYYY-MM') AS month,
      SUM(amount)::NUMERIC AS paid
    FROM payments WHERE status = 'Paid' AND paid_date >= DATE_TRUNC('month', NOW()) - make_interval(months => $1)
    GROUP BY DATE_TRUNC('month', paid_date) ORDER BY month
  `, { bind: [months], type: QueryTypes.SELECT }) as any[];

  const revenueByType = await sequelize.query(`
    SELECT payment_type, SUM(amount)::NUMERIC AS total
    FROM payments WHERE status = 'Paid'
    GROUP BY payment_type ORDER BY total DESC
  `, { type: QueryTypes.SELECT }) as any[];

  return {
    ...(invoiceStats || {}),
    upcomingPayments,
    revenueByMonth,
    revenueByType,
  };
}