"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listInvoices = listInvoices;
exports.getInvoiceById = getInvoiceById;
exports.createInvoice = createInvoice;
exports.updateInvoice = updateInvoice;
exports.updateInvoiceStatus = updateInvoiceStatus;
exports.deleteInvoice = deleteInvoice;
exports.listPayments = listPayments;
exports.createPayment = createPayment;
exports.updatePaymentStatus = updatePaymentStatus;
exports.listLedger = listLedger;
exports.createLedgerEntry = createLedgerEntry;
exports.createLedgerPair = createLedgerPair;
exports.listValuations = listValuations;
exports.createValuation = createValuation;
exports.getFinanceSummary = getFinanceSummary;
const sequelize_1 = require("sequelize");
const database_1 = require("../../config/database");
const finance_model_1 = require("./finance.model");
const player_model_1 = require("../players/player.model");
const club_model_1 = require("../clubs/club.model");
const user_model_1 = require("../Users/user.model");
const errorHandler_1 = require("../../middleware/errorHandler");
const pagination_1 = require("../../shared/utils/pagination");
const PLAYER_ATTRS = ['id', 'firstName', 'lastName', 'firstNameAr', 'lastNameAr', 'photoUrl'];
const CLUB_ATTRS = ['id', 'name', 'nameAr', 'logoUrl'];
// ══════════════════════════════════════════
// INVOICES
// ══════════════════════════════════════════
async function listInvoices(queryParams) {
    const { limit, offset, page, sort, order, search } = (0, pagination_1.parsePagination)(queryParams, 'createdAt');
    const where = {};
    if (queryParams.status)
        where.status = queryParams.status;
    if (queryParams.playerId)
        where.playerId = queryParams.playerId;
    if (queryParams.clubId)
        where.clubId = queryParams.clubId;
    if (search) {
        where[sequelize_1.Op.or] = [
            { invoiceNumber: { [sequelize_1.Op.iLike]: `%${search}%` } },
            { description: { [sequelize_1.Op.iLike]: `%${search}%` } },
            { '$player.first_name$': { [sequelize_1.Op.iLike]: `%${search}%` } },
            { '$player.last_name$': { [sequelize_1.Op.iLike]: `%${search}%` } },
            { '$club.name$': { [sequelize_1.Op.iLike]: `%${search}%` } },
        ];
    }
    const { count, rows } = await finance_model_1.Invoice.findAndCountAll({
        where, limit, offset, order: [[sort, order]], subQuery: false,
        include: [
            { model: player_model_1.Player, as: 'player', attributes: [...PLAYER_ATTRS] },
            { model: club_model_1.Club, as: 'club', attributes: [...CLUB_ATTRS] },
        ],
    });
    return { data: rows, meta: (0, pagination_1.buildMeta)(count, page, limit) };
}
async function getInvoiceById(id) {
    const inv = await finance_model_1.Invoice.findByPk(id, {
        include: [
            { model: player_model_1.Player, as: 'player', attributes: [...PLAYER_ATTRS] },
            { model: club_model_1.Club, as: 'club', attributes: [...CLUB_ATTRS] },
            { model: user_model_1.User, as: 'creator', attributes: ['id', 'fullName'] },
        ],
    });
    if (!inv)
        throw new errorHandler_1.AppError('Invoice not found', 404);
    return inv;
}
async function createInvoice(input, userId) {
    // invoice_number auto-generated by DB trigger
    return await finance_model_1.Invoice.create({ ...input, invoiceNumber: '', createdBy: userId });
}
async function updateInvoice(id, input) {
    const inv = await finance_model_1.Invoice.findByPk(id);
    if (!inv)
        throw new errorHandler_1.AppError('Invoice not found', 404);
    if (inv.status === 'Paid')
        throw new errorHandler_1.AppError('Cannot modify a paid invoice', 400);
    return await inv.update(input);
}
async function updateInvoiceStatus(id, input) {
    const inv = await finance_model_1.Invoice.findByPk(id);
    if (!inv)
        throw new errorHandler_1.AppError('Invoice not found', 404);
    const data = { status: input.status };
    if (input.status === 'Paid')
        data.paidDate = input.paidDate || new Date().toISOString().split('T')[0];
    return await inv.update(data);
}
async function deleteInvoice(id) {
    const inv = await finance_model_1.Invoice.findByPk(id);
    if (!inv)
        throw new errorHandler_1.AppError('Invoice not found', 404);
    if (inv.status === 'Paid')
        throw new errorHandler_1.AppError('Cannot delete a paid invoice', 400);
    await inv.destroy();
    return { id };
}
// ══════════════════════════════════════════
// PAYMENTS
// ══════════════════════════════════════════
async function listPayments(queryParams) {
    const { limit, offset, page, sort, order } = (0, pagination_1.parsePagination)(queryParams, 'dueDate');
    const where = {};
    if (queryParams.status)
        where.status = queryParams.status;
    if (queryParams.paymentType)
        where.paymentType = queryParams.paymentType;
    if (queryParams.playerId)
        where.playerId = queryParams.playerId;
    const { count, rows } = await finance_model_1.Payment.findAndCountAll({
        where, limit, offset, order: [[sort, order]],
        include: [{ model: player_model_1.Player, as: 'player', attributes: [...PLAYER_ATTRS] }],
    });
    return { data: rows, meta: (0, pagination_1.buildMeta)(count, page, limit) };
}
async function createPayment(input) {
    return await finance_model_1.Payment.create(input);
}
async function updatePaymentStatus(id, input) {
    const pay = await finance_model_1.Payment.findByPk(id);
    if (!pay)
        throw new errorHandler_1.AppError('Payment not found', 404);
    const data = { status: input.status };
    if (input.status === 'Paid')
        data.paidDate = input.paidDate || new Date().toISOString().split('T')[0];
    if (input.reference)
        data.reference = input.reference;
    return await pay.update(data);
}
// ══════════════════════════════════════════
// LEDGER
// ══════════════════════════════════════════
async function listLedger(queryParams) {
    const { limit, offset, page, sort, order, search } = (0, pagination_1.parsePagination)(queryParams, 'postedAt');
    const where = {};
    if (queryParams.side)
        where.side = queryParams.side;
    if (queryParams.account)
        where.account = { [sequelize_1.Op.iLike]: `%${queryParams.account}%` };
    if (queryParams.playerId)
        where.playerId = queryParams.playerId;
    if (search) {
        where[sequelize_1.Op.or] = [
            { description: { [sequelize_1.Op.iLike]: `%${search}%` } },
            { account: { [sequelize_1.Op.iLike]: `%${search}%` } },
        ];
    }
    const { count, rows } = await finance_model_1.LedgerEntry.findAndCountAll({
        where, limit, offset, order: [[sort, order]],
        include: [{ model: player_model_1.Player, as: 'player', attributes: [...PLAYER_ATTRS] }],
    });
    return { data: rows, meta: (0, pagination_1.buildMeta)(count, page, limit) };
}
async function createLedgerEntry(input, userId) {
    return await finance_model_1.LedgerEntry.create({ ...input, createdBy: userId });
}
// ── Create a balanced double-entry pair ──
async function createLedgerPair(debitAccount, creditAccount, amount, description, refType, refId, playerId, userId) {
    const txId = require('crypto').randomUUID();
    const base = { transactionId: txId, amount, currency: 'SAR', description, referenceType: refType, referenceId: refId, playerId, createdBy: userId };
    await finance_model_1.LedgerEntry.bulkCreate([
        { ...base, side: 'Debit', account: debitAccount },
        { ...base, side: 'Credit', account: creditAccount },
    ]);
    return txId;
}
// ══════════════════════════════════════════
// VALUATIONS
// ══════════════════════════════════════════
async function listValuations(queryParams) {
    const { limit, offset, page, sort, order } = (0, pagination_1.parsePagination)(queryParams, 'valuedAt');
    const where = {};
    if (queryParams.playerId)
        where.playerId = queryParams.playerId;
    const { count, rows } = await finance_model_1.Valuation.findAndCountAll({
        where, limit, offset, order: [[sort, order]],
        include: [{ model: player_model_1.Player, as: 'player', attributes: [...PLAYER_ATTRS] }],
    });
    return { data: rows, meta: (0, pagination_1.buildMeta)(count, page, limit) };
}
async function createValuation(input) {
    const player = await player_model_1.Player.findByPk(input.playerId);
    if (!player)
        throw new errorHandler_1.AppError('Player not found', 404);
    // Auto-compute trend from previous valuation
    const prev = await finance_model_1.Valuation.findOne({ where: { playerId: input.playerId }, order: [['valued_at', 'DESC']] });
    if (prev && !input.trend) {
        const prevVal = Number(prev.value);
        if (input.value > prevVal) {
            input.trend = 'up';
            input.changePct = ((input.value - prevVal) / prevVal * 100).toFixed(2);
        }
        else if (input.value < prevVal) {
            input.trend = 'down';
            input.changePct = ((input.value - prevVal) / prevVal * 100).toFixed(2);
        }
        else {
            input.trend = 'stable';
            input.changePct = 0;
        }
    }
    return await finance_model_1.Valuation.create(input);
}
// ══════════════════════════════════════════
// FINANCE SUMMARY (for KPIs + overview)
// ══════════════════════════════════════════
async function getFinanceSummary(months = 12) {
    const [invoiceStats] = await database_1.sequelize.query(`
    SELECT
      SUM(CASE WHEN status = 'Paid' THEN total_amount ELSE 0 END)::NUMERIC AS total_paid,
      SUM(CASE WHEN status = 'Expected' THEN total_amount ELSE 0 END)::NUMERIC AS total_pending,
      SUM(CASE WHEN status = 'Overdue' THEN total_amount ELSE 0 END)::NUMERIC AS total_overdue,
      COUNT(*) FILTER (WHERE status = 'Overdue')::INT AS overdue_count,
      COUNT(*)::INT AS total_invoices
    FROM invoices
  `, { type: sequelize_1.QueryTypes.SELECT });
    const upcomingPayments = await finance_model_1.Payment.count({ where: { status: 'Expected' } });
    const revenueByMonth = await database_1.sequelize.query(`
    SELECT TO_CHAR(DATE_TRUNC('month', paid_date), 'YYYY-MM') AS month,
      SUM(amount)::NUMERIC AS paid
    FROM payments WHERE status = 'Paid' AND paid_date >= DATE_TRUNC('month', NOW()) - make_interval(months => $1)
    GROUP BY DATE_TRUNC('month', paid_date) ORDER BY month
  `, { bind: [months], type: sequelize_1.QueryTypes.SELECT });
    const revenueByType = await database_1.sequelize.query(`
    SELECT payment_type, SUM(amount)::NUMERIC AS total
    FROM payments WHERE status = 'Paid'
    GROUP BY payment_type ORDER BY total DESC
  `, { type: sequelize_1.QueryTypes.SELECT });
    return {
        ...(invoiceStats || {}),
        upcomingPayments,
        revenueByMonth,
        revenueByType,
    };
}
//# sourceMappingURL=finance.service.js.map